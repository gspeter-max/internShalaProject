
import os
import subprocess
import typing
from io import BytesIO
import google 
from google import  genai
import PIL
import requests
from crewai import LLM
from crewai.tools import BaseTool
from PIL import Image
from pydantic import BaseModel, Field

class TerminalCommandInput(BaseModel):
    """Input schema for the PromptToTerminalCommandTool."""
    prompt: str = Field(..., description="The natural language instruction to convert into a shell command. Example: 'Show disk space usage'.")

class ExecutionInput(BaseModel):
    """Input schema for the TerminalCodeExecutor tool."""
    commands: typing.List[str] = Field(..., description="A list of valid shell command strings to execute sequentially.")

class ImageGeneratorInput(BaseModel):
    """Input schema for the ImageGenerationTool."""
    prompt: str = Field(..., description="A detailed text description for the image to be generated. Example: 'A bar chart of user engagement metrics.'")
    showImage: bool = Field(False, description="If True, attempts to display the generated image locally for debugging. Defaults to False.")

class SendTextInTelegramInput(BaseModel):
    """Input schema for the SendTextInTelegramChannel tool."""
    Content: str = Field(..., description="The text message content to be sent to the Telegram channel.")

class SendImageInTelegramInput(BaseModel):
    """
    Input schema for the SendImageInTelegramChannel tool.
    
    This tool takes no arguments because its sole purpose is to read a
    pre-generated file (`image.png`) from disk and send it.
    """
    pass # No arguments needed.


class ConvertPromptToTerminalCommand(BaseTool):
    """
    A Natural Language to Shell Command Interpreter.

    Purpose & Use Case:
    This tool acts as a critical bridge between an agent's high-level goal and the
    low-level execution environment. An agent should use this tool first when a
    task requires interacting with the local system (e.g., "check file permissions,"
    "list running processes").

    Workflow Integration:
    The output of this tool is a clean command string, designed to be passed
    directly to the `TerminalCodeExecutor` tool for execution.
    """
    name: str = 'PromptToTerminalCommandTool'
    description: str = (
        "Translates a natural-language request into a valid shell command string. "
        "Return ONLY the command, with no explanations or formatting. "
        "This is the first step before executing any system operations."
    )
    args_schema: typing.Type[BaseModel] = TerminalCommandInput

    async def _run(self, prompt: str) -> str:
        """
        Executes the tool's logic to convert a prompt into a command.

        Args:
            prompt: The natural language instruction provided by the agent.
            
        Returns:
            A string containing the generated shell command, ready for execution.
        """
        llm = LLM(
            model='gemini/gemini-1.5-flash',
            api_key=os.environ.get('GOOGLE_API_KEY', '')
        )
        response = llm.call(
            messages=f'''
                You are an expert shell command generator. Convert the following request into a single, valid shell command.
                Return ONLY the command and nothing else. No explanations, no markdown, no backticks.

                Request: "{prompt}"
                '''
        )
        return response.strip()

class TerminalExecution(BaseTool):
    """
    A Secure Shell Command Executor.

    Purpose & Use Case:
    Provides a controlled and observable way for an agent to interact with the
    operating system. It captures both standard output and standard error,
    giving the agent full context of the command's success or failure.

    Workflow Integration:
    This tool consumes the output of `PromptToTerminalCommandTool`. The agent uses
    the returned stdout/stderr to understand the system's state and decide its next step.
    
    WARNING:
    Using `shell=True` can be a security risk if the command is user-generated.
    Ensure commands are generated by a trusted agent process.
    """
    name: str = "TerminalCodeExecutor"
    description: str = (
        "Executes a list of shell commands in the system terminal and returns "
        "their outputs. Captures stdout or stderr for each command. "
        "Essential for any task requiring direct system interaction."
    )
    args_schema: typing.Type[BaseModel] = ExecutionInput

    async def _run(self, commands: typing.List[str]) -> str:
        """
        Executes a list of shell commands and returns their collected output.

        Args:
            commands: A list of command strings to execute.

        Returns:
            A string representation of a list containing the stdout or stderr
            for each executed command, providing a complete execution log.
        """
        OutputList = []
        for cmd in commands:
            try:
                process_output = subprocess.run(
                    cmd,
                    shell=True,
                    capture_output=True,
                    text=True,
                    check=False
                )
                if process_output.stderr:
                    OutputList.append(f"ERROR: {process_output.stderr.strip()}")
                else:
                    OutputList.append(process_output.stdout.strip())
            except Exception as e:
                OutputList.append(f"EXECUTION FAILED for command '{cmd}': {e}")

        return str(OutputList)

class ImageGenerationTool(BaseTool):
    """
    An AI-Powered Visual Asset Generator.

    Purpose & Use Case:
    Creates high-quality images (charts, diagrams, illustrations) from text
    prompts. An agent should use this tool when a task's output would be
    enhanced by a visual component.

    Workflow Integration:
    This tool is a producer. Its primary side effect is creating a file named
    `image.png` in the current working directory. It is the mandatory prerequisite
    for using the `SendImageInTelegramChannel` tool.
    """
    name: str = 'ImageGenerationTool'
    description: str = (
        "Generates a visual asset (chart, diagram, etc.) from a text prompt. "
        "This tool saves the result to a file named 'image.png'. "
        "It MUST be called before you can use the SendImageInTelegramChannel tool."
    )
    args_schema: typing.Type[BaseModel] = ImageGeneratorInput

    async def _run(self, prompt: str, showImage: bool = False) -> str:
        """
        Generates an image and saves it to the local filesystem.

        Args:
            prompt: A detailed, descriptive prompt for the image to be generated.
            showImage: If True, attempts to open the image locally for debugging.

        Returns:
            A confirmation message indicating success and the file path, or an
            error message on failure.
        """
        try:
            client = genai.Client(api_key=os.environ['GOOGLE_API_KEY'])
            response = client.models.generate_content(
                model='gemini-2.0-flash-preview-image-generation',
                contents=prompt,
                config=google.genai.types.GenerateContentConfig(
                    responseModalities=['IMAGE', 'TEXT']
                )
            )
            
            img_data = None
            for part in response.candidates[0].content.parts:
                if part.inline_data:
                    img_data = part.inline_data.data
                    break
            
            if img_data is None:
                return "Image generation failed: No image data was returned by the API."

            img = Image.open(BytesIO(img_data))
            
            if showImage:
                img.show()

            image_path = './image.png'
            img.save(image_path)

            return (
                f"Image generated successfully and saved to '{image_path}'. "
                "You can now use the 'SendImageInTelegramChannel' tool to send it."
            )
        except Exception as e:
            return f"An error occurred during image generation: {e}"

class SendTextInTelegramChannel(BaseTool):
    """
    A Dedicated Text Message Distributor for Telegram.

    Purpose & Use Case:
    This is a final delivery tool. An agent should use this tool to send its
    final textual findings, summaries, or reports to the designated Telegram channel.

    Workflow Integration:
    This tool is a consumer of text. It typically runs at the end of a task
    chain after an agent has formulated its final answer.
    """
    name: str = 'SendTextInTelegramChannel'
    description: str = "Sends a text message to the configured Telegram channel. Use this for all final text-based outputs."
    args_schema: typing.Type[BaseModel] = SendTextInTelegramInput
    bot_api_key: str = os.environ.get('bot_api_key')
    chat_id: str = os.environ.get('telegram_chat_id')

    async def _run(self, Content: str) -> str:
        """
        Sends a given text string to the configured Telegram channel.

        Args:
            Content: The message text to be sent.

        Returns:
            A string indicating the result of the API call, including status code.
        """
        if not self.bot_api_key or not self.chat_id:
            return "Error: Telegram `bot_api_key` or `telegram_chat_id` is not configured in environment variables."

        post_url = f'https://api.telegram.org/bot{self.bot_api_key}/sendMessage'
        data = {'chat_id': self.chat_id, 'text': Content}
        response = requests.post(post_url, data=data)
        return f"Telegram API response: {response.status_code} - {response.text}"

class SendImageInTelegramChannel(BaseTool):
    """
    A Dedicated Image Distributor for Telegram.

    Purpose & Use Case:
    This is a final delivery tool for visual content. An agent should use this
    tool ONLY AFTER the `ImageGenerationTool` has successfully run.

    Workflow Integration:
    This tool is a consumer of the `image.png` file. It acts as the second part
    of a two-step "generate then send" process. It takes no arguments because
    its target file is predetermined.
    """
    name: str = 'SendImageInTelegramChannel'
    description: str = "Sends the 'image.png' file to the configured Telegram channel. CRITICAL: 'ImageGenerationTool' must be used successfully before calling this."
    args_schema: typing.Type[BaseModel] = SendImageInTelegramInput
    bot_api_key: str = os.environ.get('bot_api_key')
    chat_id: str = os.environ.get('telegram_chat_id')

    async def _run(self) -> str:
        """
        Finds 'image.png', loads it, and sends it to the Telegram channel.

        Returns:
            A string indicating the result of the API call, including status code.
        """
        if not self.bot_api_key or not self.chat_id:
            return "Error: Telegram `bot_api_key` or `telegram_chat_id` is not configured in environment variables."
        
        image_path = './image.png'
        if not os.path.exists(image_path):
            return f"Error: Image file not found at '{image_path}'. You must run the ImageGenerationTool first."

        post_url = f'https://api.telegram.org/bot{self.bot_api_key}/sendPhoto'
        
        try:
            with open(image_path, 'rb') as img_file:
                files = {'photo': img_file}
                data = {'chat_id': self.chat_id, 'caption': ''} 
                response = requests.post(post_url, files=files, data=data)
            return f"Telegram API response: {response.status_code} - {response.text}"
        except Exception as e:
            return f"An error occurred while sending the image: {e}"
